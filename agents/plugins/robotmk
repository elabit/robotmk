#!/usr/bin/env python3

#Maintainer: Michael FRANK <michael.frank@mikefrank.de>
#Version: 0.0.1
import os 
import sys
import shutil
from pathlib import Path

#robot options whith a list of multiple values needs a special handling to
#add global options to local options.
LISTOPTIONS = ['settag',
               'variable',
               'critical',
               'noncritical',
               'test',
               'task',
               'suite',
               'include',
               'exclude',
               'tagstatinclude',
               'tagstatexclude',
               'tagstatcombine',
               'tagdoc',
               'tagstatlink',
               'removekeywords',
               'flattenkeywords',
               'listener',
               'prerunmodifier',
               'prerebotmodifier',
               'pythonpath']

########################  Debug handling ############################
debug = 0
if '--debug' in sys.argv: debug = 1

#In Windows beside robot also pyYAML needs to be installed seperate.
try:
   import yaml
except:
   if debug: print('You need pyYAML to run this plugin.')
   exit(1)
try:
   from robot import run
except:
   if debug: print('You need robotframework installed to run this plugin.')
   exit(1)

######################### set default values ################################
if debug: print('############### Starting preperation ###############')
if os.name == 'nt':
   #We are in the Windows world
   cfg = {'outputdir': 'C:/temp',
      #Building the path to the robot directory with help of the environment variable 'DataDirectory' or use default path if not set
       'robotdir' : Path(os.environ.setdefault('DataDirectory','C:/ProgramData/checkmk/agent')).joinpath('robot'),
       'log'      : 'none',
       'console'  : 'none',
       'report'   : 'none',
       }
   #Building the path to the configuration file with help of the environment variable 'AgentDirectory' or use default path if not set
   CMKCONFIG = Path(os.environ.setdefault('AgentDirectory','C:/ProgramData/checkmk/agent/config')).joinpath('robotmk').with_suffix('.yml')
elif os.name == 'posix':
   #We are in the UNIX/Linux world
   cfg = {'outputdir': '/tmp',
       #Building the path to the robot directory with help of the environment variable 'DataDirectory' or use default path if not set
       'robotdir' : Path(os.environ.setdefault('DataDirectory','/usr/lib/check_mk_agent')).joinpath('robot'),
       'log'      : 'none',
       'console'  : 'none',
       'report'   : 'none',
       }
   #Building the path to the configuration file with help of the environment variable 'AgentDirectory' or use default path if not set
   CMKCONFIG = Path(os.environ.setdefault('AgentDirectory','/etc/check_mk')).joinpath('robotmk').with_suffix('.yml')
else:
   # We are not on a supported OS
   if debug: print(f'\tOS Name {os.name} is not supported by robotmk')
   exit(1)

if debug: print(f'\tLooking for config file: {CMKCONFIG}')
######################## Read configuration #########################
if os.access(CMKCONFIG, os.R_OK):
   if debug: print(f'\tFound configuration file {CMKCONFIG}')
   try:
      with CMKCONFIG.open(mode='r') as stream:   
         cfg.update(yaml.safe_load(stream))
   except yaml.YAMLError as exc:
      if debug: print ("\tError while parsing YAML file:")
      if hasattr(exc, 'problem_mark') and debug:
         if exc.context != None:
            print ('\t  parser says:\n\t' + str(exc.problem_mark) + '\n\t  ' +
               str(exc.problem) + ' ' + str(exc.context) +
               '\n\tPlease correct data and retry.')
         else:
            print ('\t  parser says\n\t' + str(exc.problem_mark) + '\n\t  ' +
                str(exc.problem) + '\n\tPlease correct data and retry.')
         exit(1)
      else:
         exit(1)
else:
   if debug: print('\tNo configuration file found, starting with defaults')

#The ROBOTDIR is the directory where robot looks for the suite files or directories
ROBOTDIR = Path(cfg.pop('robotdir', None))

#If no suites are defined we setup an empty suite dict.
#This is necessary to later on fill the dict.
cfg.setdefault('suites',{})
#If no suites defined we run each suite we find in ROBOTDIR
if len(cfg['suites']) == 0:
   if debug: print('\tNo suites found in configuration file')
   for suite in ROBOTDIR.iterdir():
      if debug: print(f'\tFound suite: {suite.name} in ROBOTDIR: {ROBOTDIR}')
      cfg['suites'].update({suite.name:{}})

######################## Run all suites we found in config or ROBOTDIR ############
for suite,options in cfg['suites'].items():
   if debug:
      print(f'################# Start running suite: {suite} #####################')
      print(f'\tStarting robot with: {ROBOTDIR.joinpath(suite)}')
   #Lets test if the file or directory is available
   if not ROBOTDIR.joinpath(suite).exists():
      if debug: print(f'\tSuite file or directory {ROBOTDIR.joinpath(suite)} not found!')
      continue
   if options is None or len(options) == 0:
      options = {}
      if debug: print(f'\tNo options set; Starting with default options')
   #Anyway we have to suppress the output from robot to stdout. checkmk cannot deal with it.
   #Except if we start in debug mode
   if debug: 
      options.update({'console':'verbose'})
   else:
      options.update({'console':'none'})
   #Set the output filename to the suitname. If the suite was a file we have to remove the extension.
   options.update({'output':suite.replace('.robot','')})
   #Merge the suite options with globally set options.
   for key in cfg:
      if key == "suites": continue
      # If the global option is a list we extend the suite list
      # If the suite option is a string and global option a list we
      # make a the suite option a list and extend it with global list.
      # If the global option is a string and suite option a list we append it
      # If both is a string we build a list.
      if key in LISTOPTIONS and type(cfg[key]) == list:
         if key not in options or options[key] == None:
            options[key] = []
         if type(options[key]) == list:
            options[key].extend(cfg[key])
         else:
            options[key] = [options[key]]
            options[key].extend(cfg[key])
      if key in LISTOPTIONS and key in options and type(cfg[key]) == str:
         if type(options[key]) == list:
            options[key].append(cfg[key])
         elif type(options[key]) == str:
            options[key] = [options[key]]
            options[key].append(cfg[key])
      options.setdefault(key, cfg[key])

   #The OUTPUTDIR is the directory where robot place all its ouput files.
   # Lets test if it is a directory and we can write to it before we start robot.
   OUTPUTDIR=Path(options['outputdir'])
   if not OUTPUTDIR.is_dir():
      if debug: print(f'\tOutput directory {OUTPUTDIR} is not a directory')
      continue
   if not os.access(OUTPUTDIR, os.W_OK):
      if debug: print(f'\tOutput directory {OUTPUTDIR} is not a writable directory')
      continue

   #In case Piggy Back host is found in the options we store it in a variable and remove it.
   #host is not a valid option for robot but its silently accepted.
   #TODO Test if this is really needed
   if 'host' in options:
      host = options.pop('host')
   if debug: print(f'\tStart with following options: {options}')
######################## Run robot run..... ###############################################
   rc = run(ROBOTDIR.joinpath(suite), **options)
   if debug: print(f'\trobot finished with returncode: {rc}\n\tLess than 250 shows number of failed tests!')
   if rc > 250: 
      if debug: print('\trobot exited with error and no outputfile is generated.')
      if debug: print ('\tPlease run robot command manually to see the error')
      break
######################## Send output.xml to checkmk #######################################
   #If a piggy back hots is defined in config we print the section header
   if 'host' in locals():
      if debug: print(f'\tFound piggy back host: {host}" in config')
      print(f'<<<<{host}>>>>')
      del host
   #print the section header
   print('<<<robotmk:sep(0)>>>')
   #Copy the content of xml file to STDOUT and delete it.
   with OUTPUTDIR.joinpath(suite).with_suffix('.xml').open(mode='r') as f:
      if debug: 
         print(f'\tCopy outputfile {OUTPUTDIR.joinpath(suite).with_suffix(".xml")} to stdout')
      else: 
         shutil.copyfileobj(f, sys.stdout)
         OUTPUTDIR.joinpath(suite).with_suffix('.xml').unlink()